#!/usr/bin/env python
import numpy as np
import scipy.signal as sig
from argparse import ArgumentParser
import os
import h5py
from pycbc.types import TimeSeries
from pycbc import frame
from datetime import datetime

from pycbc.filter import asd2

ap = ArgumentParser(description='Takes input transfer functions and cleans h(t) '+
                'data using the relevant aux channel. The cleaned data can then '+
                'be written to disk')
ap.add_argument('--gps-start-time',type=int,required=True,
                help='Start time to calculate the transfer functions. '+
                'Note that there is an initial loss of time due to corruption.')
ap.add_argument('--gps-end-time',type=int,required=True,
                help='End time to calculate the transfer functions. '+
                'Note that there is an final loss of time due to corruption.')
ap.add_argument('--tf-file',required=True,
                help='Path to file containing relevant transfer functions')
ap.add_argument('--ifo',required=True,
                help='IFO')
ap.add_argument('--output-frame-directory', default='./',
                help='Location of output files')
ap.add_argument('--output-frame-type', default='C00',
                help='Type of strain being written in the output file')
ap.add_argument('--output-frame-channel',
                help='Name of strain channel in output file.')
ap.add_argument('--file-size',default=4096,
                help='Maximum file duration (seconds)')
ap.add_argument('--strain-frame-type',
                help='Frame type of input strain')
ap.add_argument('--project', action='store_true')
ap.add_argument('--no-strain', action='store_true')
args = ap.parse_args()

#Input information, passed as arguments
datadir=args.output_frame_directory
ifo = args.ifo
start_data=args.gps_start_time
end_data=args.gps_end_time
file_size = args.file_size

#Read in transfer functions and set up cleaning parameters
tf_dict,start_list,aux_chan_list,duration_tf,filter_length = asd2.read_tf_hdf(args.tf_file,start_data,end_data)
cut = int(np.ceil(0.5*filter_length))
duration_data = end_data - start_data - 2*cut
write_size = np.ceil(float(file_size)/float(duration_tf))

#Set buffer to none 
#Will be added to later
noise_data_buffer = None
noise_channel_name = 'DCH-SUBTRACTED_NOISE'
noise_frame_tag = 'SUBTRACTED_NOISE' 

strain_data_buffer = None
strain_channel_name = 'DCH-CLEAN_STRAIN'
strain_frame_tag = 'HOFT_CLEANED'

print "Removing noise using:"
print aux_chan_list

#Clean each chunk seperately
#will be added together at end
for tf_start in start_list:
    print "Working on data starting at:", tf_start
 
    #sets time for start and end
    st = tf_start
    ed = st + duration_tf
    if (st == start_list[-1]):
        ed = end_data

    #Grab data - This is all based on gwpy reading methods - MAKE AS A FUNCTION - ONLY READ IN NEEDED DATA
    print str(datetime.now()),"  reading data..."
    data, aux_data = asd2.read_in(st,ed,aux_chan_list,cut,ifo,strain_frame_type=args.strain_frame_type)
    print "data starts out with", data.duration

    #picks out which set of tf to use
    det_tf = tf_dict[tf_start]

    #cleaning that chunk
    print str(datetime.now()),"  cleaning data..."
    data_nojit, noise_subtracted = asd2.clean_data(data,aux_data,det_tf)

    #Add data to the buffer, and write out if needed
    print str(datetime.now()),"  adding to buffer..."
    if args.project:
        noise_data_buffer = asd2.add_buffer(noise_subtracted, prev_buffer=noise_data_buffer, dur=duration_tf, 
                                      write=True, write_size=write_size, data_dir=datadir, 
                                      ifo=ifo, output_channel=noise_channel_name, frame_tag=noise_frame_tag)
    if not args.no_strain:
        strain_data_buffer = asd2.add_buffer(data_nojit, prev_buffer=strain_data_buffer, dur=duration_tf, 
                                      write=True, write_size=write_size, data_dir=datadir, 
                                      ifo=ifo, output_channel=strain_channel_name, frame_tag=strain_frame_tag)

#Write the remaining data tail to frames
if args.project:
    noise_fname = "%s/%s-%s_%s-%u-%u.gwf" % (datadir,
               ifo, args.output_frame_type, noise_frame_tag, int(noise_data_buffer.start_time), int(noise_data_buffer.duration))
    frame.write_frame(noise_fname, '%s:%s' % (ifo, noise_channel_name), noise_data_buffer)

if not args.no_strain:
    strain_fname = "%s/%s-%s_%s-%u-%u.gwf" % (datadir,
               ifo, args.output_frame_type, strain_frame_tag, int(strain_data_buffer.start_time), int(strain_data_buffer.duration))
    frame.write_frame(strain_fname, '%s:%s' % (ifo, strain_channel_name), strain_data_buffer)

