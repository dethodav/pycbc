#!/usr/bin/env python

# Copyright (C) 2017 Derek Davis and TJ Massinger
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import numpy as np
import scipy.signal as sig
from argparse import ArgumentParser
import os
import h5py
from pycbc.types import TimeSeries
from pycbc import frame
from datetime import datetime
import logging

from pycbc.filter import crosstalk


ap = ArgumentParser(description='Takes input transfer functions and cleans h(t)')
ap.add_argument('--input-frame-file',
                help='Path to file containing relevant input timeseries')
ap.add_argument('--input-frame-type',
                help='Type of frame file to use as input')
ap.add_argument('--ifo',required=True,
                help='IFO')
ap.add_argument('--input-channel',required=True,
                help='Strain channel to read')
ap.add_argument('--noise-frame-file',required=True, nargs='+',
                help='Path to file containing relevant noise timeseries')
ap.add_argument('--noise-channel', required=True, nargs='+',
                help='Noise channel(s) to read')
ap.add_argument('--output-frame-file', default='./CLEANED_FRAME.gwf',
                help='Path of output frame file')
ap.add_argument('--output-channel-name', default='./CLEANED_CHANNEL',
                help='Path of output frame file')
args = ap.parse_args()

logging.basicConfig(format='%(asctime)s %(message)s', level=logging.INFO)


ifo = args.ifo

noise_frames = args.noise_frame_file
noise_channels = args.noise_channel
if len(noise_channels) ==1:
    noise_channels = [noise_channels[0]] * len(noise_frames)
assert len(noise_frames) == len(noise_channels)

#read in data from frame
if args.input_frame_file:
    data = frame.read_frame(args.input_frame_file,'%s'%(args.input_channel))
elif args.input_frame_type:
    noise = frame.read_frame(noise_frames[0],'%s'%(noise_channels[0]))
    data = frame.query_and_read_frame(args.input_frame_type,
               '%s'%(args.input_channel), noise.start_time, noise.end_time,sieve='hdfs')
else:
    sys.exit("Need either input frame or input frame type.")
noise_data = []
for frame_file, frame_channel in zip(noise_frames,noise_channels):
    noise = frame.read_frame(frame_file,'%s'%(frame_channel))
    data = data - noise

strain_fname = args.output_frame_file
frame.write_frame(strain_fname, '%s' % (args.output_channel_name), data)
logging.info('Frame file {} is written!'.format(strain_fname))
